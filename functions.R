################################################################################
# Authors: Sergei Bychkov, Ivo Rakovac
# Copyright: WHO NCD Office
################################################################################

# MAIN FUNCTIONS
# 1. tbls_summary() - calculates means, percentages, and medians as a list of data 
# frames (including both parts of a data book table: age range rows & total row)
# 2. tbls_list_split() - splits the original list (by sex, urban/rural, region) 
# made by the tbls_summary() function into smaller lists for joining later with 
# the join function, join_tbls(), in the data book
# 3. fs_summary() - creates a fact sheet summary

# SUPPORTING FUNCTIONS
# 1. unite_ci() - unites lower and upper confidence intervals into one CI variable
# 2. apply_hux() - creates hux tables, using huxtable package
# 3. join_tbls() - creates individual hux tables and joining them into one list 
# (men, women, both sexes, urban, and rural disaggregations)
# 4. final_tbl() - applies styling to hux tables generated by join_tbls() function 
# (men, women, both sexes, urban/rural, regional)
# 5. forestplot_steps() - creates forest plots in vector graphics (PDF, SVG, EMF) 
# and saves them into specific folders

################################################################################

# Load packages
library(tidyverse)
library(srvyr) # load this package as a general rule if not present in each script
library(huxtable) # for creating hux tables with RMD files
library(svglite) # for forestplots function

################################################################################
# MAIN FUNCTIONS
################################################################################
# MEANS, PERCENTAGES & MEDIANS
################################################################################

# A FUNCTION FOR COVERING BOTH PARTS (AGERANGE ROWS + TOTAL ROW)
# MEN, WOMEN & BOTH SEXES
# Arguments description:
# .data - name of the data frame
# .wt_unwt - weighted or unweighted analysis
# .mn_pct_md - means, percentages, or medians selection
# .variable - variable name
# .cln - clean (CLN) variable as used in EpiInfo programme scripts (up to three CLN variables)
# .cln_val - value for each clean variable (up to three values)
# .agerange_var - name of the age range variable (set to agerange by default)
# .agerange_u_r_var - for urban, rural disaggregation (set to agerange2 by default)

# PERCENTAGES
# Track changes/updates:
# - covers CVDrisk.R with only two age ranges (hence adjustable .agerange_var argument in the function)

tbls_summary <- function(.data = STEPSClean, .wt_unwt = wt, .mn_pct_md, .variable, 
                         .cln = cln, .cln_val = 1, .cln2 = FALSE, .cln2_val = FALSE, 
                         .cln3 = FALSE, .cln3_val = FALSE, 
                         .agerange_var = agerange, .agerange_u_r_var = agerange2) {
  ##############################################################################
  # DEFINE CORE FUNCTIONS
  ##############################################################################
  # FUNCTION FOR SUMMARIZE MEAN IN SRVYR
  # Arguments description:
  # .data - name of the data frame
  # .variable - variable name 
  summary_mn <- function(.data, .variable) {
    srvyr::summarise(
      .data, 
      # Calculating n for individual answer choices
      n = unweighted(n()), 
      # Calculating standard error, confidence intervals and design effect
      m = survey_mean({{ .variable }}, vartype = c("ci","se"), deff = TRUE)) %>% 
      # Rounding possible negative numbers to zero
      mutate(m_low = ifelse(m_low <0, 0, m_low)) %>% 
      # Convert NA values to 0 in the output for a clean look
      mutate(m_low = ifelse(is.na(m_low), 0, m_low)) %>% 
      mutate(m_upp = ifelse(is.na(m_upp), 0, m_upp)) %>% 
      mutate(m_deff = ifelse(is.na(m_deff), 0, m_deff))
  }
  
  ##############################################################################
  
  # UNWEIGHTED MEAN
  # Arguments description:
  # .data - name of the data frame
  # .variable - variable name 
  summary_mn_unwt <- function(.data, .variable) {
    dplyr::summarise(
      .data, 
      n = n(),
      m = mean({{ .variable }})) 
  }
  
  ##############################################################################
  
  # FUNCTION FOR SUMMARIZE PCT IN SRVYR
  # Arguments description:
  # .data - name of the data frame
  summary_pct <- function(.data) {
    srvyr::summarise(
      .data, 
      # Calculating n for individual answer choices
      n = unweighted(n()), 
      # Calculating standard error, confidence intervals and design effect
      m = survey_mean(vartype = c("ci","se"), deff = TRUE)) %>% 
      # Rounding possible negative numbers to zero
      mutate(m_low = ifelse(m_low<0, 0, m_low)) %>% 
      # Calculating a sum of all n answer choices
      mutate(n_sum = sum(n), .after = n) %>% 
      # Convert specific columns to % (except m_deff)
      mutate(across(c(m,m_low,m_upp,m_se), ~100*.x)) %>% 
      # Convert NA values to 0 in the output for a clean look
      mutate(m_low = ifelse(is.na(m_low), 0, m_low)) %>% 
      mutate(m_upp = ifelse(is.na(m_upp), 0, m_upp)) %>% 
      mutate(m_deff = ifelse(is.na(m_deff), 0, m_deff))
  }
  
  ##############################################################################
  
  # UNWEIGHTED PCT
  # Arguments description:
  # .data - name of the data frame
  summary_pct_unwt <- function(.data) {
    dplyr::summarise(
      .data, 
      n = n()) %>%
      mutate(m = (n / sum(n))*100) %>% 
      # Calculating a sum of all n answer choices
      mutate(n_sum = sum(n), .after = n)
  }
  
  ##############################################################################
  
  # FUNCTION TO SUMMARIZE *MEDIAN* IN SRVYR SPECIFICALLY FOR PHYSICAL ACTIVITY AND OTHER SUCH CASES
  # Arguments description:
  # .data - name of the data frame
  # .variable - variable name 
  summary_md <- function(.data, .variable) {
    srvyr::summarise(
      .data, 
      # Calculating n for individual answer choices
      n = unweighted(n()), 
      md = survey_median({{ .variable }}, vartype = c("ci","se")),
      q = survey_quantile({{ .variable }}, quantiles = c(0.25, 0.75))) 
  }
  
  ##############################################################################
  # MAIN BODY OF tbls_summary() FUNCTION
  ##############################################################################
  
  # Prep passing arguments with or without quotes to tbls_summary() function, using rlang
  .wt_unwt <- rlang::quo_name(rlang::enquo(.wt_unwt))
  .mn_pct_md <- rlang::quo_name(rlang::enquo(.mn_pct_md))
  
  # Pipe filter function based on weighted/unweighted, means, percentages, or medians
  # Filter potential NAs in .variable (not inside summarize, as it impacts n-variable in the output)
  # (Copies the same logic as in EpiInfo)
  # filter_mn_pct_md <- . %>% 
  #   {if(.mn_pct_md=="mn" | .mn_pct_md=="md") filter(., !is.na({{ .variable }}), 
  #                                                   {{ .cln }} == {{ .cln_val }}, 
  #                                                   {{ .cln2 }} == {{ .cln2_val }}, 
  #                                                   {{ .cln3 }} == {{ .cln3_val }}) 
  #     else if(.mn_pct_md=="pct") filter(., {{ .cln }} == {{ .cln_val }}, 
  #                                       {{ .cln2 }} == {{ .cln2_val }}, 
  #                                       {{ .cln3 }} == {{ .cln3_val }}) 
  #     else stop("Argument .mn_pct_md must be specified.")}
  # 2nd version:
  filter_mn_pct_md <- . %>% 
    {if(.mn_pct_md=="mn" | .mn_pct_md=="md") filter(., !is.na({{ .variable }}), 
                                                    {{ .cln }} == {{ .cln_val }}, 
                                                    {{ .cln2 }} == {{ .cln2_val }}, 
                                                    {{ .cln3 }} == {{ .cln3_val }}) else .} %>% 
    {if(.mn_pct_md=="pct") filter(., {{ .cln }} == {{ .cln_val }}, 
                                  {{ .cln2 }} == {{ .cln2_val }}, 
                                  {{ .cln3 }} == {{ .cln3_val }}) else .}
  
  # Pipe summary function based on weighted/unweighted, means, percentages, or medians
  # summary_mn_pct_md_wt_unwt <- . %>% 
  #   # MEANS, WEIGHTED/UNWEIGHTED
  #   {if(.wt_unwt=="wt" & .mn_pct_md=="mn") summary_mn(., .variable = {{ .variable }}) 
  #     else if(.wt_unwt=="unwt" & .mn_pct_md=="mn") summary_mn_unwt(., .variable = {{ .variable }})
  #     # PERCENTAGES, WEIGHTED/UNWEIGHTED
  #     else if(.wt_unwt=="wt" & .mn_pct_md=="pct") summary_pct(.) 
  #     else if(.wt_unwt=="unwt" & .mn_pct_md=="pct") summary_pct_unwt(.) 
  #     # MEDIANS, WEIGHTED/UNWEIGHTED
  #     else if(.wt_unwt=="wt" & .mn_pct_md=="md") summary_md(., .variable = {{ .variable }}) 
  #     else if(.wt_unwt=="unwt" & .mn_pct_md=="md") summary_md_unwt(., .variable = {{ .variable }}) 
  #     else stop("Both arguments .wt_unwt and .mn_pct_md must be specified.")}
  # 2nd version which may be better:
  summary_mn_pct_md_wt_unwt <- . %>% 
    # MEANS, WEIGHTED/UNWEIGHTED
    {if(.wt_unwt=="wt" & .mn_pct_md=="mn") summary_mn(., .variable = {{ .variable }}) else .} %>% 
    {if(.wt_unwt=="unwt" & .mn_pct_md=="mn") summary_mn_unwt(., .variable = {{ .variable }}) else .} %>%
    # PERCENTAGES, WEIGHTED/UNWEIGHTED
    {if(.wt_unwt=="wt" & .mn_pct_md=="pct") summary_pct(.) else .} %>% 
    {if(.wt_unwt=="unwt" & .mn_pct_md=="pct") summary_pct_unwt(.) else .} %>% 
    # MEDIANS, WEIGHTED/UNWEIGHTED
    {if(.wt_unwt=="wt" & .mn_pct_md=="md") summary_md(., .variable = {{ .variable }}) else .} %>% 
    {if(.wt_unwt=="unwt" & .mn_pct_md=="md") summary_md_unwt(., .variable = {{ .variable }}) else .}
    
  
  
  # FOR MEANS & MEDIANS
  ##############################################################################
  if(.u_r_reg == FALSE & (.mn_pct_md == "mn" | .mn_pct_md == "md")) {
    # without urban/rural and regional disaggregation
    ############################################################################
    # MEN, WOMEN
    tbl_m_w <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, sex, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt
    # MEN, WOMEN - TOTALS
    tbl_m_w_t <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(sex, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1)
    # MEN, WOMEN - JOINED
    tbl_m_w_t_j <- rbind(tbl_m_w, tbl_m_w_t)
    
    # BOTH SEXES
    tbl_b <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - TOTAL
    tbl_b_t <- .data %>% 
      filter_mn_pct_md %>% 
      summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - JOINED
    tbl_b_t_j <- rbind(tbl_b, tbl_b_t)
    
    # MEN, WOMEN, BOTH SEXES - JOINED
    tbls_m_w_b <- rbind(tbl_m_w_t_j, tbl_b_t_j) %>% ungroup()
    
    return(tbls_m_w_b)
    
  } else if(.u_r_reg == TRUE & (.mn_pct_md == "mn" | .mn_pct_md == "md")) {
    ############################################################################
    # 1
    # MEN, WOMEN
    tbl_m_w <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, sex, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt
    # MEN, WOMEN - TOTALS
    tbl_m_w_t <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(sex, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1)
    # MEN, WOMEN - JOINED
    tbl_m_w_t_j <- rbind(tbl_m_w, tbl_m_w_t)
    
    # BOTH SEXES
    tbl_b <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - TOTAL
    tbl_b_t <- .data %>% 
      filter_mn_pct_md %>% 
      summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - JOINED
    tbl_b_t_j <- rbind(tbl_b, tbl_b_t)
    
    # MEN, WOMEN, BOTH SEXES - JOINED
    tbls_m_w_b <- rbind(tbl_m_w_t_j, tbl_b_t_j) %>% ungroup()
    
    ############################################################################
    # 2
    # URBAN, RURAL - MEN, WOMEN
    tbl_m_w_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_u_r_var }}, sex, ur, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt
    # TOTALS
    tbl_m_w_t_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(sex, ur, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_u_r_var }}" := factor("18–69"), .before = 1)
    # JOINED
    tbls_m_w_u_r_j <- rbind(tbl_m_w_u_r, tbl_m_w_t_u_r)
    
    # URBAN, RURAL - BOTH SEXES
    tbl_b_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_u_r_var }}, ur, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # TOTALS
    tbl_b_t_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(ur, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_u_r_var }}" := factor("18–69"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # JOINED
    tbls_b_u_r_j <- rbind(tbl_b_u_r, tbl_b_t_u_r)
    
    # URBAN, RURAL - MEN, WOMEN, BOTH SEXES - JOINED
    tbls_m_w_b_u_r_j <- rbind(tbls_m_w_u_r_j, tbls_b_u_r_j) %>% ungroup()
    
    ############################################################################
    # 3
    # REGION (BOTH SEXES ONLY)
    tbl_b_reg <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(region, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # TOTAL
    tbl_b_t_reg <- .data %>% 
      filter_mn_pct_md %>% 
      summary_mn_pct_md_wt_unwt %>% 
      mutate(region = factor("Total"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # JOINED
    tbl_b_t_reg_j <- rbind(tbl_b_reg, tbl_b_t_reg) %>% ungroup()
    
    ############################################################################
    
    # joining all main tables into one list
    m_w_b_u_r_reg <- c("m_w_b","m_w_b_u_r","b_reg")
    tbls <- 
      list(
        # men, women, both
        tbls_m_w_b,
        # urban, rural (men, women, both)
        tbls_m_w_b_u_r_j,
        # region (both only)
        tbl_b_t_reg_j) %>% setNames(m_w_b_u_r_reg)
    
    return(tbls)
    
  } 
  ##############################################################################
  # FOR PERCENTAGES
  ##############################################################################
  else if(.u_r_reg == FALSE & .mn_pct_md == "pct") {
    # without urban/rural and regional disaggregation
    ############################################################################
    # MEN, WOMEN
    tbl_m_w <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, sex, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt
    # MEN, WOMEN - TOTALS
    tbl_m_w_t <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(sex, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1)
    # MEN, WOMEN - JOINED
    tbl_m_w_t_j <- rbind(tbl_m_w, tbl_m_w_t)
    
    # BOTH SEXES
    tbl_b <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - TOTAL
    tbl_b_t <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - JOINED
    tbl_b_t_j <- rbind(tbl_b, tbl_b_t)
    
    # MEN, WOMEN, BOTH SEXES - JOINED
    tbls_m_w_b <- rbind(tbl_m_w_t_j, tbl_b_t_j) %>% ungroup()
    
    return(tbls_m_w_b)
    
  } else if(.u_r_reg == TRUE & .mn_pct_md == "pct") {
    ############################################################################
    # 1
    # MEN, WOMEN
    tbl_m_w <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, sex, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt
    # MEN, WOMEN - TOTALS
    tbl_m_w_t <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(sex, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1)
    # MEN, WOMEN - JOINED
    tbl_m_w_t_j <- rbind(tbl_m_w, tbl_m_w_t)
    
    # BOTH SEXES
    tbl_b <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_var }}, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - TOTAL
    tbl_b_t <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_var }}" := factor("18–69"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # BOTH SEXES - JOINED
    tbl_b_t_j <- rbind(tbl_b, tbl_b_t)
    
    # MEN, WOMEN, BOTH SEXES - JOINED
    tbls_m_w_b <- rbind(tbl_m_w_t_j, tbl_b_t_j) %>% ungroup()
    
    ############################################################################
    # 2
    # URBAN, RURAL - MEN, WOMEN
    tbl_m_w_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_u_r_var }}, sex, ur, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt
    # TOTALS
    tbl_m_w_t_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(sex, ur, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_u_r_var }}" := factor("18–69"), .before = 1)
    # JOINED
    tbls_m_w_u_r_j <- rbind(tbl_m_w_u_r, tbl_m_w_t_u_r)
    
    # URBAN, RURAL - BOTH SEXES
    tbl_b_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .agerange_u_r_var }}, ur, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # TOTALS
    tbl_b_t_u_r <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(ur, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate("{{ .agerange_u_r_var }}" := factor("18–69"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # JOINED
    tbls_b_u_r_j <- rbind(tbl_b_u_r, tbl_b_t_u_r)
    
    # URBAN, RURAL - MEN, WOMEN, BOTH SEXES - JOINED
    tbls_m_w_b_u_r_j <- rbind(tbls_m_w_u_r_j, tbls_b_u_r_j) %>% ungroup()
    
    ############################################################################
    # 3
    # REGION (BOTH SEXES ONLY)
    tbl_b_reg <- .data %>% 
      filter_mn_pct_md %>% 
      group_by(region, {{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # TOTAL
    tbl_b_t_reg <- .data %>% 
      filter_mn_pct_md %>% 
      group_by({{ .variable }}, .drop = FALSE) %>% summary_mn_pct_md_wt_unwt %>% 
      mutate(region = factor("Total"), .before = 1) %>% 
      mutate(sex = factor("Both sexes"), .before = 2)
    # JOINED
    tbl_b_t_reg_j <- rbind(tbl_b_reg, tbl_b_t_reg) %>% 
      ungroup() # ungroup for dropping columns when/if needed
    
    ############################################################################
    
    # joining all main tables into one list
    m_w_b_u_r_reg <- c("m_w_b","m_w_b_u_r","b_reg")
    tbls <- 
      list(
        # men, women, both
        tbls_m_w_b,
        # urban, rural (men, women, both)
        tbls_m_w_b_u_r_j,
        # region (both only)
        tbl_b_t_reg_j) %>% setNames(m_w_b_u_r_reg)
    
    return(tbls)
    
  }
}

################################################################################

# TABLES LIST SPLIT FUNCTION
# Function to prep tables with one variable output and split the original list into smaller lists 
# for joining with join functions for men, women, both sexes and urban/rural, region
# Track changes/updates:
# - includes two use-cases when you need to produce a list of pct tables with 
# one variable/column (out of initial two) and when you need tables with 
# many variables/columns (without dropping columns)
# - includes means as well as percentages
# - includes a check on "m_w_b_u_r" presence in the list of tables (when .u_r_reg <<- TRUE)
# 
# Arguments description:
# .data - name of the data frame
# .select_var - indicate the needed variable
# .vars_amount_number - amount of variables (i.e., number of answer choices in the question)
# .select_var_val - indicate the value (i.e., answer choice) of the variable (for cases 
# when there are two answers and only one is needed in the output). It is skipped by default (set to FALSE).

tbls_list_split <- function(.data, .select_var, .vars_amount_number, .select_var_val = FALSE) {
  
  ##############################################################################
  # DEFINE CORE FUNCTION sort_rename_vars()
  ##############################################################################
  # Pivots the table (for percentages with more than two answer choices) and 
  # rename columns for standardization to produce the output used in data book.
  # Generates tables with up to eight variables/answer choices.
  # Arguments description:
  # .var - variable name
  # .vars_amount - amount of variables (i.e., number of answer choices in the question) 
  # in the table/data frame (can be up to 8)
  # .var_val - value (i.e., answer choice) of the variable. When there are two answer 
  # choices, then typically the final output (in data book) will have only one of those 
  # two answers. In this case, select that required answer using the .var_val argument.
  
  sort_rename_vars <- function(.data, .var, .vars_amount, .var_val) {
    
    # WEIGHTED DATA
    ############################################################################
    # FOR PERCENTAGES
    if((.vars_amount == 8) & ("m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = c(m, m_low, m_upp, m_se, m_deff)) %>%
        select(c(1,2,3,11,19,4,12,20,5,13,21,6,14,22,7,15,23,8,16,24,9,17,25,10,18,26)) %>%
        rename(m1=3, m_low1=4, m_upp1=5,
               m2=6, m_low2=7, m_upp2=8,
               m3=9, m_low3=10, m_upp3=11,
               m4=12, m_low4=13, m_upp4=14,
               m5=15, m_low5=16, m_upp5=17,
               m6=18, m_low6=19, m_upp6=20,
               m7=21, m_low7=22, m_upp7=23,
               m8=24, m_low8=25, m_upp8=26)
    }
    else if ((.vars_amount == 7) & ("m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = c(m, m_low, m_upp, m_se, m_deff)) %>%
        select(c(1,2,3,10,17,4,11,18,5,12,19,6,13,20,7,14,21,8,15,22,9,16,23)) %>%
        rename(m1=3, m_low1=4, m_upp1=5,
               m2=6, m_low2=7, m_upp2=8,
               m3=9, m_low3=10, m_upp3=11,
               m4=12, m_low4=13, m_upp4=14,
               m5=15, m_low5=16, m_upp5=17,
               m6=18, m_low6=19, m_upp6=20,
               m7=21, m_low7=22, m_upp7=23)
    }
    else if ((.vars_amount == 6) & ("m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = c(m, m_low, m_upp, m_se, m_deff)) %>%
        select(c(1,2,3,9,15,4,10,16,5,11,17,6,12,18,7,13,19,8,14,20)) %>%
        rename(m1=3, m_low1=4, m_upp1=5,
               m2=6, m_low2=7, m_upp2=8,
               m3=9, m_low3=10, m_upp3=11,
               m4=12, m_low4=13, m_upp4=14,
               m5=15, m_low5=16, m_upp5=17,
               m6=18, m_low6=19, m_upp6=20)
    }
    else if ((.vars_amount == 5) & ("m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = c(m, m_low, m_upp, m_se, m_deff)) %>%
        select(c(1,2,3,8,13,4,9,14,5,10,15,6,11,16,7,12,17)) %>%
        rename(m1=3, m_low1=4, m_upp1=5,
               m2=6, m_low2=7, m_upp2=8,
               m3=9, m_low3=10, m_upp3=11,
               m4=12, m_low4=13, m_upp4=14,
               m5=15, m_low5=16, m_upp5=17)
    }
    else if ((.vars_amount == 4) & ("m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = c(m, m_low, m_upp, m_se, m_deff)) %>%
        select(c(1,2,3,7,11,4,8,12,5,9,13,6,10,14)) %>%
        rename(m1=3, m_low1=4, m_upp1=5,
               m2=6, m_low2=7, m_upp2=8,
               m3=9, m_low3=10, m_upp3=11,
               m4=12, m_low4=13, m_upp4=14)
    }
    else if (.vars_amount == 3) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = c(m, m_low, m_upp, m_se, m_deff)) %>%
        select(c(1,2,3,6,9,4,7,10,5,8,11)) %>%
        rename(m1=3, m_low1=4, m_upp1=5,
               m2=6, m_low2=7, m_upp2=8,
               m3=9, m_low3=10, m_upp3=11)
    }
    # for questions with two answer choices (one in the output)
    else if (.vars_amount == 2) {
      .data %>% 
        # filter only one answer choice 
        filter({{ .var }} == {{ .var_val }}) %>% 
        # drop columns irrelevant for data book 
        select(-c(n, {{ .var }}, m_se, m_deff)) %>% 
        # prep specific columns for huxtable functions later
        rename(m1=3, m_low1=4, m_upp1=5)
    }
    # FOR MEANS
    else if ((.vars_amount == 0) & (!"md" %in% names(.data)) & ("m_low" %in% names(.data))) {
      .data %>% 
        select(c(1,2,3,4,5)) %>% 
        rename(m1=3, m_low1=4, m_upp1=5)
    }
    # FOR MEDIANS
    else if ((.vars_amount == 0) & ("md" %in% names(.data)) & (!"m_low" %in% names(.data))) {
      .data %>% 
        select(c(1,2,3,7,8))
    }
    # UNWEIGHTED DATA
    ############################################################################
    else if ((.vars_amount == 8) & (!"m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = m) %>% 
        rename(m1=3, m2=4, m3=5, m4=6, m5=7, m6=8, m7=9, m8=10)
    }
    else if ((.vars_amount == 7) & (!"m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = m) %>% 
        rename(m1=3, m2=4, m3=5, m4=6, m5=7, m6=8, m7=9)
    }
    else if ((.vars_amount == 6) & (!"m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = m) %>% 
        rename(m1=3, m2=4, m3=5, m4=6, m5=7, m6=8)
    }
    else if ((.vars_amount == 5) & (!"m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = m) %>% 
        rename(m1=3, m2=4, m3=5, m4=6, m5=7)
    }
    else if ((.vars_amount == 4) & (!"m_low" %in% names(.data))) {
      .data %>% 
        # drop "n" column for pct cases to keep only the overall "n_sum" column
        select(-n) %>% 
        # pivot wider from a long format 
        pivot_wider(names_from = {{ .var }}, values_from = m) %>% 
        rename(m1=3, m2=4, m3=5, m4=6)
    }
    # FOR MEANS (UNWT)
    else if ((.vars_amount == 0) & (!"md" %in% names(.data)) & (!"m_low" %in% names(.data))) {
      .data %>% 
        select(c(1,2,3))
    }
  }
  
  ##############################################################################
  # MAIN BODY OF tbls_list_split() FUNCTION
  ##############################################################################
  # MEN, WOMEN, BOTH SEXES WITH ADDITONAL DISAGGREGATIONS (URBAN, RURAL, REGION)
  # FOR PERCENTAGES
  # ONLY ONE ANSWER CHOICE OUTPUT (2 vars initially)
  if(.vars_amount_number == 2 & (.GlobalEnv$.u_r_reg == TRUE)) {
    # men, women, both sexes - split by sex into a list
    tbls_m_w_b_bysex <- 
      split(.data$m_w_b, .data$m_w_b$sex) %>% 
      setNames(c("m","w","b")) %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.var = {{ .select_var }}, 
                             .vars_amount = {{ .vars_amount_number }}, 
                             .var_val = {{ .select_var_val }}))
    # men, women, both sexes - urban, rural - split by sex and ur into a list
    tbls_m_w_b_u_r_bysex <- 
      split(.data$m_w_b_u_r, paste(.data$m_w_b_u_r$sex, .data$m_w_b_u_r$ur)) %>% 
      setNames(c("b_r","b_u","m_r","m_u","w_r","w_u")) %>% 
      map(~ select(., -c(sex,ur)) %>% 
            sort_rename_vars(.var = {{ .select_var }}, 
                             .vars_amount = {{ .vars_amount_number }}, 
                             .var_val = {{ .select_var_val }}))
    # both sexes - region - cleaned for joining
    tbl_b_reg <- list(.data$b_reg) %>% 
      setNames("b_reg") %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.var = {{ .select_var }}, 
                             .vars_amount = {{ .vars_amount_number }}, 
                             .var_val = {{ .select_var_val }}))
    # merge three above lists into one
    tbls <- c(tbls_m_w_b_bysex, tbls_m_w_b_u_r_bysex, tbl_b_reg)
  } 
  # FOR PERCENTAGES
  # SEVERAL ANSWER CHOICES
  else if (.vars_amount_number > 2 & (.GlobalEnv$.u_r_reg == TRUE)) {
    # men, women, both sexes - split by sex into a list
    tbls_m_w_b_bysex <- 
      split(.data$m_w_b, .data$m_w_b$sex) %>% 
      setNames(c("m","w","b")) %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.var = {{ .select_var }}, .vars_amount = {{ .vars_amount_number }}))
    # men, women, both sexes - urban, rural - split by sex and ur into a list
    tbls_m_w_b_u_r_bysex <- 
      split(.data$m_w_b_u_r, paste(.data$m_w_b_u_r$sex, .data$m_w_b_u_r$ur)) %>% 
      setNames(c("b_r","b_u","m_r","m_u","w_r","w_u")) %>% 
      map(~ select(., -c(sex,ur)) %>% 
            sort_rename_vars(., .var = {{ .select_var }}, .vars_amount = {{ .vars_amount_number }}))
    # both sexes - region - cleaned for joining
    tbl_b_reg <- list(.data$b_reg) %>% 
      setNames("b_reg") %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.var = {{ .select_var }}, 
                             .vars_amount = {{ .vars_amount_number }}))
    # merge three above lists into one
    tbls <- c(tbls_m_w_b_bysex, tbls_m_w_b_u_r_bysex, tbl_b_reg)
  }
  # FOR MEANS
  else if (.vars_amount_number == 0 & (.GlobalEnv$.u_r_reg == TRUE)) {
    # men, women, both sexes - split by sex into a list
    tbls_m_w_b_bysex <- 
      split(.data$m_w_b, .data$m_w_b$sex) %>% 
      setNames(c("m","w","b")) %>% 
      map(~ select(., -sex) %>% sort_rename_vars(.vars_amount = {{ .vars_amount_number }})) 
    # men, women, both sexes - urban, rural - split by sex and ur into a list
    tbls_m_w_b_u_r_bysex <- 
      split(.data$m_w_b_u_r, paste(.data$m_w_b_u_r$sex, .data$m_w_b_u_r$ur)) %>% 
      setNames(c("b_r","b_u","m_r","m_u","w_r","w_u")) %>% 
      map(~ select(., -c(sex,ur)) %>% 
            sort_rename_vars(.vars_amount = {{ .vars_amount_number }}))
    # both sexes - region - cleaned for joining
    tbl_b_reg <- list(.data$b_reg) %>% 
      setNames("b_reg") %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.vars_amount = {{ .vars_amount_number }}))
    # merge three above lists into one
    tbls <- c(tbls_m_w_b_bysex, tbls_m_w_b_u_r_bysex, tbl_b_reg)
  }
  ##############################################################################
  # MEN, WOMEN, BOTH SEXES ONLY # without urban/rural and regional disaggregation
  # NOTE: .data that is used below is not a list, as was in above sections
  # FOR PERCENTAGES
  # ONLY ONE ANSWER CHOICE OUTPUT (2 vars initially)
  else if (.vars_amount_number == 2 & (.GlobalEnv$.u_r_reg == FALSE)) {
    # men, women, both sexes - split by sex into a list
    tbls_m_w_b_bysex <- 
      split(.data, .data$sex) %>% 
      setNames(c("m","w","b")) %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.var = {{ .select_var }}, 
                             .vars_amount = {{ .vars_amount_number }}, 
                             .var_val = {{ .select_var_val }}))
    # output
    tbls <- c(tbls_m_w_b_bysex)
  }
  # FOR PERCENTAGES
  # SEVERAL ANSWER CHOICES (pivoted wider tables)
  else if (.vars_amount_number > 2 & (.GlobalEnv$.u_r_reg == FALSE)) {
    # men, women, both sexes - split by sex into a list
    tbls_m_w_b_bysex <- 
      split(.data, .data$sex) %>% 
      setNames(c("m","w","b")) %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.var = {{ .select_var }}, 
                             .vars_amount = {{ .vars_amount_number }}))
    # output
    tbls <- c(tbls_m_w_b_bysex)
  }
  # FOR MEANS (without a column with answer choices)
  else if (.vars_amount_number == 0 & (.GlobalEnv$.u_r_reg == FALSE)) {
    # men, women, both sexes - split by sex into a list
    tbls_m_w_b_bysex <- 
      split(.data, .data$sex) %>% 
      setNames(c("m","w","b")) %>% 
      map(~ select(., -sex) %>% 
            sort_rename_vars(.vars_amount = {{ .vars_amount_number }}))
    # output
    tbls <- c(tbls_m_w_b_bysex)
  }
  
  return(tbls)
  
}

################################################################################

# FACTSHEET FUNCTION
# Arguments description:
# .data - specify the data frame
# .sel_var - selection of variables for the Fact Sheet
# .name_val - enter column names for either men, women or both sexes
# .pct - toggle option for adding of "%" sign to values

fs_summary <- function(.data, .sel_var, .name_val, .pct) {
  
  if (missing(.pct)) {
    .data %>% 
      # select note: use column numbers instead of names when they are too long
      select({{ .sel_var }}) %>%
      # renaming to bring every column to a standard naming
      # some df have longer names and some df don't, hence the following renaming
      rename(m=1, m_low=2, m_upp=3) %>% 
      ##########################################################################
    # Keeping zeros after decimal point 
    mutate(m = sprintf("%.1f", m)) %>% 
      mutate(m_low = sprintf("%.1f", m_low)) %>% 
      mutate(m_upp = sprintf("%.1f", m_upp)) %>% 
      ##########################################################################
    # joining upper & lower CI into one column
    unite(ci, m_low, m_upp, sep = "–", remove = TRUE) %>% 
      # adding parenthesis to CI
      mutate(ci = replace(ci, ci==ci, paste0("(", ci, ")"))) %>% 
      # joining the above together
      unite({{ .name_val }}, m, ci, sep = " ", remove = TRUE)
  } 
  else {
    .data %>% 
      # select note: use column numbers instead of names when they are too long
      select({{ .sel_var }}) %>%
      # renaming to bring every column to a standard naming
      # some df have longer names and some df don't, hence the following renaming
      rename(m=1, m_low=2, m_upp=3) %>% 
      ##########################################################################
    # Keeping zeros after decimal point 
    mutate(m = sprintf("%.1f", m)) %>% 
      mutate(m_low = sprintf("%.1f", m_low)) %>% 
      mutate(m_upp = sprintf("%.1f", m_upp)) %>% 
      ##########################################################################
    # joining upper & lower CI into one column
    unite(ci, m_low, m_upp, sep = "–", remove = TRUE) %>% 
      # adding % sign to pct column
      mutate(m = replace(m, m==m, paste0(m, "%"))) %>% 
      # adding parenthesis to CI
      mutate(ci = replace(ci, ci==ci, paste0("(", ci, ")"))) %>% 
      # joining the above together
      unite({{ .name_val }}, m, ci, sep = " ", remove = TRUE)
  }
  
}

################################################################################
# SUPPORTING FUNCTIONS
################################################################################

# Function to unite lower and upper confidence intervals into one CI variable
# Arguments description:
# .data - name of the data frame
# .ci_amount - value for the amount of CIs variables/columns in the table 
# (from 1 to 8, or "q" is used for PA Inter-quartile range (P25-P75))

unite_ci <- function(.data, .ci_amount) {
  ##############################################################################
  # Prep passing arguments with or without quotes to unite_ci() function, using rlang
  .ci_amount <- rlang::quo_name(rlang::enquo(.ci_amount))
  ##############################################################################
  if(.ci_amount == 8) {
    .data %>%
      unite(ci1, m_low1, m_upp1, sep = "–", remove = TRUE) %>%
      unite(ci2, m_low2, m_upp2, sep = "–", remove = TRUE) %>%
      unite(ci3, m_low3, m_upp3, sep = "–", remove = TRUE) %>%
      unite(ci4, m_low4, m_upp4, sep = "–", remove = TRUE) %>% 
      unite(ci5, m_low5, m_upp5, sep = "–", remove = TRUE) %>%
      unite(ci6, m_low6, m_upp6, sep = "–", remove = TRUE) %>% 
      unite(ci7, m_low7, m_upp7, sep = "–", remove = TRUE) %>% 
      unite(ci8, m_low8, m_upp8, sep = "–", remove = TRUE)
  } 
  else if (.ci_amount == 7) {
    .data %>% 
      unite(ci1, m_low1, m_upp1, sep = "–", remove = TRUE) %>%
      unite(ci2, m_low2, m_upp2, sep = "–", remove = TRUE) %>%
      unite(ci3, m_low3, m_upp3, sep = "–", remove = TRUE) %>%
      unite(ci4, m_low4, m_upp4, sep = "–", remove = TRUE) %>% 
      unite(ci5, m_low5, m_upp5, sep = "–", remove = TRUE) %>%
      unite(ci6, m_low6, m_upp6, sep = "–", remove = TRUE) %>% 
      unite(ci7, m_low7, m_upp7, sep = "–", remove = TRUE)
  }
  else if (.ci_amount == 6) {
    .data %>% 
      unite(ci1, m_low1, m_upp1, sep = "–", remove = TRUE) %>%
      unite(ci2, m_low2, m_upp2, sep = "–", remove = TRUE) %>%
      unite(ci3, m_low3, m_upp3, sep = "–", remove = TRUE) %>%
      unite(ci4, m_low4, m_upp4, sep = "–", remove = TRUE) %>% 
      unite(ci5, m_low5, m_upp5, sep = "–", remove = TRUE) %>%
      unite(ci6, m_low6, m_upp6, sep = "–", remove = TRUE) 
  }
  else if (.ci_amount == 5) {
    .data %>% 
      unite(ci1, m_low1, m_upp1, sep = "–", remove = TRUE) %>%
      unite(ci2, m_low2, m_upp2, sep = "–", remove = TRUE) %>%
      unite(ci3, m_low3, m_upp3, sep = "–", remove = TRUE) %>%
      unite(ci4, m_low4, m_upp4, sep = "–", remove = TRUE) %>% 
      unite(ci5, m_low5, m_upp5, sep = "–", remove = TRUE)
  }
  else if (.ci_amount == 4) {
    .data %>%
      unite(ci1, m_low1, m_upp1, sep = "–", remove = TRUE) %>%
      unite(ci2, m_low2, m_upp2, sep = "–", remove = TRUE) %>%
      unite(ci3, m_low3, m_upp3, sep = "–", remove = TRUE) %>%
      unite(ci4, m_low4, m_upp4, sep = "–", remove = TRUE) 
  }
  else if (.ci_amount == 3) {
    .data %>%  
      unite(ci1, m_low1, m_upp1, sep = "–", remove = TRUE) %>%
      unite(ci2, m_low2, m_upp2, sep = "–", remove = TRUE) %>%
      unite(ci3, m_low3, m_upp3, sep = "–", remove = TRUE) 
  }
  else if (.ci_amount == 1) {
    .data %>%  
      unite(ci, m_low1, m_upp1, sep = "–", remove = TRUE) 
  }
  # added specifically for PA Inter-quartile range (P25-P75)
  else if (.ci_amount == "q") {
    .data %>%
      unite(q, q_q25, q_q75, sep = "–", remove = TRUE) 
  }
}

################################################################################

# Function to create hux tables
# Arguments description:
# .data - name of the data frame
# .col_names - value for the column names list

apply_hux <- function(.data, .col_names) {
  .data %>%
    # convert to a hux table using the hux function
    hux() %>%
    # apply a hux theme
    theme_compact() %>% 
    # add column names
    set_contents(1, everywhere, {{ .col_names }}) %>%
    # borders around table
    set_outer_borders() %>%
    # border for header row
    set_top_border(row = 2, everywhere) %>%
    # border for total row
    set_top_border(final(1), everywhere) %>%
    # make the table headings bold (IF NEEDED)
    style_headers(bold = FALSE) %>%
    #OR use: set_bold(row = 1, col = everywhere) %>% 
    # make total row bold
    set_bold(final(1), everywhere) %>%
    # other small tweaks
    set_position("left") %>%
    set_font_size(value = 8) %>%
    set_width(1.2) %>%
    set_align(value = "center") %>%
    set_valign(value = "middle") %>% 
    set_number_format(row=-1, col=-c(1,2), value=1)
}

################################################################################

# Function for creating individual hux tables and joining them into one list 
# (men, women, both sexes, urban, and rural disaggregations)
# Arguments description:
# .data - name of the data frame
# .disaggregation - either men, women, both sexes (m_w_b) or urban/rural (u_r), or region (reg)
# .ci_amount_val - value for the amount of CIs in the table
# .col_names_val - value for the column names list

join_tbls <- function(.data, .disaggregation, .ci_amount_val, .col_names_val) {
  ##############################################################################
  # Prep passing arguments with or without quotes to join_tbls() function, using rlang
  .disaggregation <- rlang::quo_name(rlang::enquo(.disaggregation))
  .ci_amount_val <- rlang::quo_name(rlang::enquo(.ci_amount_val))
  ##############################################################################
  # MEN, WOMEN, BOTH SEXES
  if(.disaggregation == "m_w_b" & .ci_amount_val == 0) {
    # for unweighted scripts (without CI)
    # men, women, both sexes
    m_w_b <- c("m","w","b")
    # create a list of dataframes
    tbls <- list(.data$m, .data$w, .data$b) %>% 
      # loop over dataframes in the list to apply hux styling
      map(~ apply_hux(., .col_names = {{ .col_names_val }})) %>% 
      set_names(m_w_b)
  } else if(.disaggregation == "m_w_b" & .ci_amount_val > 0) {
    # for weighted scripts (with CI)
    # men, women, both sexes
    m_w_b <- c("m","w","b")
    # create a list of dataframes
    tbls <- list(.data$m, .data$w, .data$b) %>% 
      # loop over dataframes in the list to join CIs and apply hux styling
      map(~ unite_ci(., .ci_amount = {{ .ci_amount_val }}) %>% 
            apply_hux(.col_names = {{ .col_names_val }})) %>% 
      set_names(m_w_b)
  } 
  # URBAN/RURAL
  else if(.disaggregation == "u_r" & .ci_amount_val == 0) {
    # for unweighted scripts (without CI)
    # urban, rural
    u_r <- c("m_u","w_u","b_u","m_r","w_r","b_r")
    tbls <- list(
      # urban
      .data$m_u, .data$w_u, .data$b_u,
      # rural
      .data$m_r, .data$w_r, .data$b_r) %>%
      map(~ apply_hux(., .col_names = {{ .col_names_val }})) %>%
      set_names(u_r)
  } else if(.disaggregation == "u_r" & .ci_amount_val > 0) {
    # for weighted scripts (with CI)
    # urban, rural
    u_r <- c("m_u","w_u","b_u","m_r","w_r","b_r")
    tbls <- list(
      # urban
      .data$m_u, .data$w_u, .data$b_u,
      # rural
      .data$m_r, .data$w_r, .data$b_r) %>%
      map(~ unite_ci(., .ci_amount = {{ .ci_amount_val }}) %>% 
            apply_hux(.col_names = {{ .col_names_val }})) %>%
      set_names(u_r)
  } else stop("Both arguments .disaggregation and .ci_amount_val must be specified.")
  return(tbls)
}

################################################################################

# Function to apply styling to hux tables generated by join_tbls() function 
# (men, women, both sexes, urban/rural, regional)
# Arguments description:
# .data - name of the data frame
# .disaggregation - either men, women, both sexes (m_w_b) or urban/rural (u_r), or region (reg)
# .s_amount - amount of sexes in the table (1 = only "Men" or "Women", or 
# "Both sexes", 3 = all three sexes included)
# .s_val - value of the sex (specified for .s_amount = 1)
# .title - title of the table
# .colspan_val - value for the column span (i.e., overall number of columns in the table)

final_tbl <- function(.data, .disaggregation, .s_amount, .s_val, .title, .colspan_val) {
  ##############################################################################
  # Prep passing arguments with or without quotes to final_tbl() function, using rlang
  .disaggregation <- rlang::quo_name(rlang::enquo(.disaggregation))
  ##############################################################################
  # MEN, WOMEN, BOTH SEXES, REGION
  # Weighted scripts
  if((.disaggregation == "m_w_b" | .disaggregation == "reg") & .s_amount == 1) {
    .data %>% 
      insert_row({{ .s_val }}, fill = "", colspan = .colspan_val) %>% 
      insert_row({{ .title }}, fill = "", colspan = .colspan_val) %>% 
      set_bold(row = c(1, 2), everywhere) %>%
      set_align(row = c(1, 2), value = "center") %>% 
      set_all_borders(row = c(1, 2), everywhere) %>% 
      set_font_size(value = 8)
  } 
  else if ((.disaggregation == "m_w_b" | .disaggregation == "reg") & .s_amount == 3) {
    .data %>% 
      insert_row(c("Age Group (years)","Men","","","Women","","","Both sexes","","")) %>% 
      insert_row({{ .title }}, fill = "", colspan = .colspan_val) %>% 
      set_bold(row = c(1, 2), everywhere) %>%
      set_align(row = c(1, 2), value = "center") %>% 
      set_all_borders(row = c(1, 2), everywhere) %>% 
      merge_cells(row = 2, col = c(8:10)) %>% merge_cells(row = 2, col = c(5:7)) %>% 
      merge_cells(row = 2, col = c(2:4)) %>% merge_cells(row = c(2:3), col = 1) %>% 
      set_right_border(row = 2, col = 1, value = 0) %>% 
      set_font_size(value = 8)
  }
  # Unweighted scripts
  else if ((.disaggregation == "m_w_b" | .disaggregation == "reg") & .s_amount == "unwt_3") {
    .data %>% 
      insert_row(c("Age Group (years)","Men","","Women","","Both sexes","")) %>% 
      insert_row({{ .title }}, fill = "", colspan = .colspan_val) %>% 
      set_bold(row = c(1, 2), everywhere) %>%
      set_align(row = c(1, 2), value = "center") %>% 
      set_all_borders(row = c(1, 2), everywhere) %>% 
      merge_cells(row = 2, col = c(6:7)) %>% merge_cells(row = 2, col = c(4:5)) %>% 
      merge_cells(row = 2, col = c(2:3)) %>% merge_cells(row = c(2:3), col = 1) %>% 
      set_right_border(row = 2, col = 1, value = 0) %>% 
      set_font_size(value = 8)
  }
  ##############################################################################
  # URBAN/RURAL
  # Weighted scripts
  else if(.disaggregation == "u_r" & .s_amount == 1) {
    .data %>% 
      # remove second header after joining urban & rural tables
      slice(-5) %>%
      # add urban and rural rows
      insert_row("Urban", after = 1, fill = "", colspan = .colspan_val) %>%
      set_bottom_border(row = 2, everywhere, value = 0) %>% 
      insert_row("Rural", after = 5, fill = "", colspan = .colspan_val) %>%
      set_bottom_border(row = 6, everywhere, value = 0) %>%
      # inserting urban and rural rows removes the right border, so set it up back again
      set_right_border(row = c(2, 6), col = 1) %>% 
      # bold urban and rural rows
      set_bold(row = c(2, 6), everywhere) %>%
      # align left urban and rural
      set_align(row = 2, value = "left") %>%
      set_align(row = 6, value = "left") %>% 
      # move urban/rural headers slightly from the left border
      set_left_padding(row = 2, col = 1, value = 8) %>% 
      set_left_padding(row = 6, col = 1, value = 8) %>% 
      # add title, select sex, prep output
      insert_row({{ .s_val }}, fill = "", colspan = .colspan_val) %>% 
      insert_row({{ .title }}, fill = "", colspan = .colspan_val) %>% 
      set_bold(row = c(1, 2), everywhere) %>%
      set_align(row = c(1, 2), value = "center") %>% 
      set_all_borders(row = c(1, 2), everywhere) %>% 
      set_font_size(value = 8)
  } 
  else if (.disaggregation == "u_r" & .s_amount == 3) {
    .data %>% 
      # remove second header after joining urban & rural tables
      slice(-5) %>%
      # add urban and rural rows
      insert_row("Urban", after = 1, fill = "", colspan = .colspan_val) %>%
      set_bottom_border(row = 2, everywhere, value = 0) %>%
      insert_row("Rural", after = 5, fill = "", colspan = .colspan_val) %>%
      set_bottom_border(row = 6, everywhere, value = 0) %>%
      # inserting urban and rural rows removes the right border, so set it up back again
      set_right_border(row = c(2, 6), col = 1) %>%
      # bold urban and rural rows
      set_bold(row = c(2, 6), everywhere) %>%
      # align left urban and rural
      set_align(row = 2, value = "left") %>%
      set_align(row = 6, value = "left") %>% 
      # move urban/rural headers slightly from the left border
      set_left_padding(row = 2, col = 1, value = 8) %>% 
      set_left_padding(row = 6, col = 1, value = 8) %>% 
      # add title, select sex, prep output
      insert_row(c("Age Group (years)","Men","","","Women","","","Both sexes","","")) %>% 
      insert_row({{ .title }}, fill = "", colspan = .colspan_val) %>% 
      set_bold(row = c(1, 2), everywhere) %>%
      set_align(row = c(1, 2), value = "center") %>% 
      set_all_borders(row = c(1, 2), everywhere) %>% 
      merge_cells(row = 2, col = c(8:10)) %>% merge_cells(row = 2, col = c(5:7)) %>% 
      merge_cells(row = 2, col = c(2:4)) %>% merge_cells(row = c(2:3), col = 1) %>% 
      set_right_border(row = 2, col = 1, value = 0) %>%
      set_font_size(value = 8)
  }
  # Unweighted scripts
  else if (.disaggregation == "u_r" & .s_amount == "unwt_3") {
    .data %>% 
      # remove second header after joining urban & rural tables
      slice(-5) %>%
      # add urban and rural rows
      insert_row("Urban", after = 1, fill = "", colspan = .colspan_val) %>%
      set_bottom_border(row = 2, everywhere, value = 0) %>%
      insert_row("Rural", after = 5, fill = "", colspan = .colspan_val) %>%
      set_bottom_border(row = 6, everywhere, value = 0) %>%
      # inserting urban and rural rows removes the right border, so set it up back again
      set_right_border(row = c(2, 6), col = 1) %>%
      # bold urban and rural rows
      set_bold(row = c(2, 6), everywhere) %>%
      # align left urban and rural
      set_align(row = 2, value = "left") %>%
      set_align(row = 6, value = "left") %>% 
      # move urban/rural headers slightly from the left border
      set_left_padding(row = 2, col = 1, value = 8) %>% 
      set_left_padding(row = 6, col = 1, value = 8) %>% 
      # add title, select sex, prep output
      insert_row(c("Age Group (years)","Men","","Women","","Both sexes","")) %>% 
      insert_row({{ .title }}, fill = "", colspan = .colspan_val) %>% 
      set_bold(row = c(1, 2), everywhere) %>%
      set_align(row = c(1, 2), value = "center") %>% 
      set_all_borders(row = c(1, 2), everywhere) %>% 
      merge_cells(row = 2, col = c(6:7)) %>% merge_cells(row = 2, col = c(4:5)) %>% 
      merge_cells(row = 2, col = c(2:3)) %>% merge_cells(row = c(2:3), col = 1) %>% 
      set_right_border(row = 2, col = 1, value = 0) %>% 
      set_font_size(value = 8)
  } else stop("Both arguments .disaggregation and .s_amount must be specified.")
}



################################################################################
################################################################################

# Function to create forest plots in vector graphics (PDF, SVG, EMF) and 
# save them into specific folders
# 
# Arguments description:
# .multi_vals - TRUE/FALSE - if one or more values should be in the output, 
# depending on the answer choices (set to FALSE by default)
# .pct_mn_md_val - pct/mn/md - specify the value for the output
# .ylab - "%"/"Mean"/"Median" - specify the labels on the plot
# .agerange - agerange/agerange2/region - specify the value for the legend, depending on disaggregation
# .folder - "Age_range_Sex"/"Urban_Rural"/"Region" - specify the output folder
# .ur - TRUE/FALSE - if urban/rural disaggregation should be used (set to FALSE by default)
# .save_plots - pdfs/svgs/emfs/empty for all three - save plots into vector 
# formats (set to generate all by default)

# NOTE: you can use ind <- "tsmokestatus_c" and/or ind <- "tsmokestatus_d" for testing 
# the for loop on a single variable (check comments inside the function)

forestplot_steps <- function(.multi_vals = FALSE, .pct_mn_md_val, 
                             .ylab, .agerange, .folder, .ur = FALSE,
                             .save_plots) {
  
  # Prep passing arguments with or without quotes to forestplot_steps() function, using rlang
  .pct_mn_md_val <- rlang::quo_name(rlang::enquo(.pct_mn_md_val))
  
  # 1 - SINGLE VALUE OUTPUT
  ##############################################################################
  # for variables with only one value to present in the output
  if(.multi_vals == FALSE) {
    
    # adjust what data to include based on the mapping spreadsheet
    # "pct_mn_md" var: percentage, mean, or median (pct/mn/md) 
    # "vals_number" var: number of output values in indicators (i.e. answer choices)
    df_mapping <- data_book_mapping %>% 
      # for percentages or means, or median and one value - "pct", "mn", "md"
      filter(pct_mn_md == {{ .pct_mn_md_val }}, vals_number==1)
    
    
    # which indicators to include by their list/script titles, using 
    # the column "include_in_analysis" (TRUE/FALSE)
    inds <- subset(df_mapping, include_in_analysis)
    
    # pull names of the selected lists/scripts into a vector
    reqnames <- inds$tbls_short_name
    
    # include matching scripts
    scripts_inc <- intersect(inds$tbls_short_name, tidy_df_all$short_name)
    
    # filter data by column 26 ("short_name") to match the vector "reqnames"
    data_inc <- tidy_df_all %>% filter(short_name %in% reqnames)
    
    # list of values/answer choices that should be excluded from plotting
    # NOTE: the var "vals_exclude" in the mapping spreadsheet contains multiple 
    # answer choices separated by ";" in a string
    vals_exclude_cln <- strsplit(inds$vals_exclude, "[;]") %>% 
      lapply(., function(x) x[!is.na(x)]) %>% as_vector()
    
    # plot with a for loop
    for (ind in intersect(inds$tbls_short_name, unique(data_inc$short_name))) {
      
      # single indicator for testing the for loop
      # ind <- "tsmokestatus_d"
      # ind <- "cvdrisk_c"
      # ind <- "pcomposition_work"
      
      # prepare data for plotting
      plotvalues <- 
        # NOTE: specific indicators require additional conditions and variable preparations,
        # as they have their own variables/columns 
        filter(
          .data = if(ind=="cvdrisk_c" | ind=="cvdrisk_d"){ 
            mutate(tidy_df_all,
                   # create a new agerange var from agerangecvd var, applying the same factor levels
                   # this is for regional plots
                   agerange = factor(ifelse(is.na(ur) & is.na(region), as.character(agerangecvd), agerange)), 
                   # the same applies to agerange2 var for urban/rural plots
                   agerange2 = factor(ifelse(!is.na(ur), as.character(agerangecvd), agerange2))) } 
          else tidy_df_all,
          short_name==ind) %>% 
        drop_na({{ .agerange }}) %>%
        # include only values that don't match vals_exclude
        filter(!var %in% vals_exclude_cln)
      
      
      tryCatch(
        {
          p <- ggplot(data = plotvalues, 
                      aes(x = {{ .agerange }}, 
                          y = if(.pct_mn_md_val=="pct" | .pct_mn_md_val=="mn") m else md, 
                          ymin = if(.pct_mn_md_val=="pct" | .pct_mn_md_val=="mn") m_low else md_low, 
                          ymax = if(.pct_mn_md_val=="pct" | .pct_mn_md_val=="mn") m_upp else md_upp, 
                          color = {{ .agerange }}, shape = if(.ur) ur)) +
            geom_pointrange(position = position_dodge(width = 1), size = 0.15) +
            ggforce::facet_col(facets = ~sex, scales = "free_y", space = "free") + # group plots by sex
            coord_flip() +  # flip coordinates (puts labels on y axis)
            labs(title = stringr::str_wrap(paste(inds$tbl_title[inds$tbls_short_name==ind]), 60)) + # add main title
            xlab(NULL) + # remove x label 
            ylab({{ .ylab }}) + # specify y label
            labs(color = if(deparse(substitute(.agerange))=="agerange" | 
                            deparse(substitute(.agerange))=="agerange2") "Age range" else "Region", 
                 shape = if(.ur) "Settlement") + # adjust label text for agerange and ur. NOTE: {{ }} syntax doesn't work here
            theme_bw() + # use a white background
            theme(text = element_text(size = 8), # set font size
                  axis.text.y = element_blank(),
                  axis.ticks.y = element_blank(),
                  panel.grid.major = element_blank(), 
                  panel.grid.minor = element_blank(), # remove xlab for cases of vals_number == 1
                  plot.title = element_text(size = 8)) + # set title's font size
            geom_hline(yintercept = 0, linetype = 2, color = "grey") + # set horizontal lines for zero
            ggsci::scale_color_lancet() # color pattern for geom points in ggplot
          
          print(p)
          
          # save into three common vectorized formats (for editing plots after saving)
          if (deparse(substitute(.save_plots))=="pdfs"){
            
            # save into PDF
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".pdf"), device = cairo_pdf, 
                   path = here("Plots", "PDFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          } else if (deparse(substitute(.save_plots))=="svgs"){
            
            # save into SVG
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".svg"), device = "svg",
                   path = here("Plots", "SVGs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          } else if (deparse(substitute(.save_plots))=="emfs"){
            
            # save into EMF
            # NOTE: EMF format requires devEMF package
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".emf"),
                   device = {function(filename, ...) devEMF::emf(file = filename, ...)},
                   path = here("Plots", "EMFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          } else {
            
            # all three formats at the same time
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".pdf"), device = cairo_pdf, 
                   path = here("Plots", "PDFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".svg"), device = "svg",
                   path = here("Plots", "SVGs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".emf"),
                   device = {function(filename, ...) devEMF::emf(file = filename, ...)},
                   path = here("Plots", "EMFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          }
          
        }, error = function(cond) {
          
          message(paste("Could not make a plot for indicator", ind))
          return(NA)
          
        }) 
      
    }
    
    
  } 
  # 2 - MULTIPLE VALUES OUTPUT
  ##############################################################################
  # for variables with several values to present in the output
  else {
    
    # adjust what data to include based on the mapping spreadsheet
    # "pct_mn_md" var: percentage, mean, or median (pct/mn/md) 
    # "vals_number" var: number of output values in indicators (i.e. answer choices)
    df_mapping <- data_book_mapping %>% 
      # for percentages and more than one value
      filter(pct_mn_md == {{ .pct_mn_md_val }}, vals_number>1)
    
    # which indicators to include by their list/script titles, using 
    # the column "include_in_analysis" (TRUE/FALSE)
    inds <- subset(df_mapping, include_in_analysis)
    
    # pull names of the selected lists/scripts into a vector
    reqnames <- inds$tbls_short_name
    
    # scripts to include that match
    scripts_inc <- intersect(inds$tbls_short_name, tidy_df_all$short_name)
    
    # filter data by column 26 ("short_name") to match the vector "reqnames"
    data_inc <- tidy_df_all %>% filter(short_name %in% reqnames)
    
    # list of values/answer choices that should be excluded from plotting
    # NOTE: the var "vals_exclude" in the mapping spreadsheet contains multiple 
    # answer choices separated by ";" in a string
    vals_exclude_cln <- strsplit(inds$vals_exclude, "[;]") %>% 
      lapply(., function(x) x[!is.na(x)]) %>% as_vector()
    
    
    # plot a for loop
    for (ind in intersect(inds$tbls_short_name, unique(data_inc$short_name))) {
      
      # single indicator for multiple answer choices testing
      # ind <- "tsmokestatus_c"
      # ind <- "raisedrisk"
      
      plotvalues <- 
        # NOTE: specific indicators require additional conditions and variable preparations,
        # as they have their own variables/columns 
        filter(
          .data = if(ind=="raisedrisk"){ 
            mutate(tidy_df_all, 
                   # create a new agerange var from agerangecvd var, applying the same factor levels
                   # this is for regional plots
                   agerange = factor(ifelse(is.na(ur) & is.na(region), as.character(agerangerr), agerange)),
                   # the same applies to agerange2 var for urban/rural plots
                   agerange2 = factor(ifelse(!is.na(ur), as.character(agerangerr), agerange2))) }
          else tidy_df_all,
          short_name==ind) %>% 
        # arrange vars on the lab (NOTE: needed for the multiple answer choices case)
        mutate(var = fct_reorder(var, desc(var))) %>% 
        drop_na({{ .agerange }}) %>% 
        # include only values that don't match vals_exclude
        filter(!var %in% vals_exclude_cln)
      
      
      tryCatch(
        {
          p <- ggplot(data=plotvalues, 
                      aes(x = var, 
                          y = if(.pct_mn_md_val=="pct" | .pct_mn_md_val=="mn") m else md, 
                          ymin = if(.pct_mn_md_val=="pct" | .pct_mn_md_val=="mn") m_low else md_low, 
                          ymax = if(.pct_mn_md_val=="pct" | .pct_mn_md_val=="mn") m_upp else md_upp, 
                          color = {{ .agerange }}, shape = if(.ur) ur)) +
            geom_pointrange(position = position_dodge(width = 1), size = 0.15) +
            ggforce::facet_col(facets = ~sex, scales = "free_y", space = "free") + # group plots by sex
            coord_flip() +  # flip coordinates (puts labels on y axis)
            labs(title = stringr::str_wrap(paste(inds$tbl_title[inds$tbls_short_name==ind]), 60)) + # add main title
            xlab(NULL) + # remove x label 
            ylab({{ .ylab }}) + # specify y label
            labs(color = if(deparse(substitute(.agerange))=="agerange" | 
                            deparse(substitute(.agerange))=="agerange2") "Age range" else "Region", 
                 shape = if(.ur) "Settlement") + # adjust label text for agerange and ur
            theme_bw() + # use a white background
            theme(text = element_text(size = 8), # set font size
                  panel.grid = element_blank(), # remove grid lines
                  plot.title = element_text(size = 8)) + # set title's font size
            geom_vline(xintercept = seq(0.5, length(plotvalues$var), by = 1), 
                       color = "gray", size = 0.5, alpha = 0.5) + # set vertical lines between x groups
            geom_hline(yintercept = 0, linetype = 2, color = "grey") + # set horizontal lines for zero
            ggsci::scale_color_lancet() # color pattern for geom points in ggplot
          
          print(p)
          
          # save into three common vectorized formats (for editing plots after saving)
          if (deparse(substitute(.save_plots))=="pdfs"){
            
            # save into PDF
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".pdf"), device = cairo_pdf, 
                   path = here("Plots", "PDFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          } else if (deparse(substitute(.save_plots))=="svgs"){
            
            # save into SVG
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".svg"), device = "svg",
                   path = here("Plots", "SVGs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          } else if (deparse(substitute(.save_plots))=="emfs"){
            
            # save into EMF
            # NOTE: EMF format requires devEMF package
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".emf"),
                   device = {function(filename, ...) devEMF::emf(file = filename, ...)},
                   path = here("Plots", "EMFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          } else {
            
            # all three formats at the same time
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".pdf"), device = cairo_pdf, 
                   path = here("Plots", "PDFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".svg"), device = "svg",
                   path = here("Plots", "SVGs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            ggsave(plot = p, filename = paste0(ind, if(.folder=="Region"){ paste0("_reg") } else if(.folder=="Urban_Rural"){ paste0("_u_r") }, ".emf"),
                   device = {function(filename, ...) devEMF::emf(file = filename, ...)},
                   path = here("Plots", "EMFs", if(!missing(.folder)) .folder ), width = 6, height = 6)
            
          }
          
        }, error = function(cond) {
          
          message(paste("Could not make a plot for indicator", ind))
          return(NA)
          
        }) 
      
    }
    
    
  }
  
  #beepr::beep() # make a sound notification upon completion
  message("Completed!")
  
}

################################################################################
################################################################################



